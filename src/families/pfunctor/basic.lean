/-
Copyright (c) 2018 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Jeremy Avigad

Polynomial functors. Also expresses the W-type construction as a polynomial functor.
(For the M-type construction, see Mtype.lean.)
-/
import tactic.interactive data.multiset families.pfunctor.family for_mathlib
universe u

/- TODO (Jeremy): move this. -/

namespace functor

variables {I J : Type u} {F : fam I ‚•§ fam J}

@[reducible]
def fam.subtype {Œ± : fam I} (p : Œ† i, Œ± i ‚Üí Prop) : fam I :=
Œª i, subtype (p i)

def fam.subtype.val {Œ± : fam I} (p : Œ† i, Œ± i ‚Üí Prop) : fam.subtype p ‚ü∂ Œ± :=
Œª i, subtype.val

def liftp {Œ± : fam I} (p : Œ† i, Œ± i ‚Üí Prop) {X : fam J} : (X ‚ü∂ F.obj Œ±) ‚Üí Prop :=
Œª x, ‚àÉ u : X ‚ü∂ F.obj (fam.subtype p), u ‚â´ F.map (fam.subtype.val p) = x

def liftr {Œ± Œ≤ : fam I} (r : Œ† i, Œ± i ‚Üí Œ≤ i ‚Üí Prop) {X : fam J} : (X ‚ü∂ F.obj Œ±) ‚Üí (X ‚ü∂ F.obj Œ≤) ‚Üí Prop :=
Œª x y, ‚àÉ u : X ‚ü∂ F.obj (Œª i, {p : Œ± i √ó Œ≤ i // r i p.fst p.snd}),
  u ‚â´ F.map (fam.subtype.val _ ‚â´ Œª i, prod.fst) = x ‚àß
  u ‚â´ F.map (fam.subtype.val _ ‚â´ Œª i, prod.snd) = y

def supp {Œ± : fam I} {X : fam J} (x : X ‚ü∂ F.obj Œ±) : set (sigma Œ±) := { y : sigma Œ± | ‚àÄ ‚¶Ép‚¶Ñ, liftp p x ‚Üí p _ y.2 }

theorem of_mem_supp {Œ± : fam I} {X : fam J} {x : X ‚ü∂ F.obj Œ±} {p : Œ† i, Œ± i ‚Üí Prop} (h : liftp p x) :
  ‚àÄ y ‚àà supp x, p _ (sigma.snd y) :=
Œª y hy, hy h

end functor

/-
A polynomial functor `P` is given by a type `A` and a family `B` of types over `A`. `P` maps
any type `Œ±` to a new type `P.apply Œ±`.

An element of `P.apply Œ±` is a pair `‚ü®a, f‚ü©`, where `a` is an element of a type `A` and
`f : B a ‚Üí Œ±`. Think of `a` as the shape of the object and `f` as an index to the relevant
elements of `Œ±`.
-/

structure pfunctor (I J : Type u) :=
(A : J ‚Üí Type u) (B : Œ† i, A i ‚Üí I ‚Üí Type u)

namespace pfunctor

variables {I J : Type u} {Œ± Œ≤ : Type u}

section pfunc
variables (P : pfunctor I J)

-- TODO: generalize to psigma?
def apply : fam I ‚•§ fam J :=
{ obj := Œª X i, Œ£ a : P.A i, P.B i a ‚ü∂ X,
  map := Œª X Y f i ‚ü®a,g‚ü©, ‚ü®a, g ‚â´ f‚ü© }

def obj := P.apply.obj
def map {X Y : fam I} (f : X ‚ü∂ Y) : P.obj X ‚ü∂ P.obj Y := P.apply.map f

lemma map_id {X : fam I} : P.map (ùüô X) = ùüô _ :=
category_theory.functor.map_id _ _

lemma map_comp {X Y Z : fam I} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : P.map (f ‚â´ g) = P.map f ‚â´ P.map g :=
category_theory.functor.map_comp _ _ _

theorem map_eq {Œ± Œ≤ : fam I} (f : Œ± ‚ü∂ Œ≤) {i : J} (a : P.A i) (g : P.B i a ‚ü∂ Œ±) :
  P.map f ‚ü®a, g‚ü© = ‚ü®a, g ‚â´ f‚ü© :=
rfl

def Idx (i : J) := Œ£ (x : P.A i) j, P.B i x j

section
variables {P}
def Idx.idx {i : J} (x : Idx P i) : I := x.2.1
end

def obj.iget {i} [decidable_eq $ P.A i] {Œ± : fam I} (x : P.obj Œ± i) (j : P.Idx i) [inhabited $ Œ± j.2.1] : Œ± j.2.1 :=
if h : j.1 = x.1
  then x.2 (cast (by rw ‚Üê h) $ j.2.2)
  else default _

end pfunc

variables (P : pfunctor I I)

-- theorem id_map {Œ± : Type*} : ‚àÄ x : P.apply Œ±, id <$> x = id x :=
-- Œª ‚ü®a, b‚ü©, rfl

-- theorem comp_map {Œ± Œ≤ Œ≥ : Type*} (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) :
--   ‚àÄ x : P.apply Œ±, (g ‚àò f) <$> x = g <$> (f <$> x) :=
-- Œª ‚ü®a, b‚ü©, rfl

-- instance : is_lawful_functor P.apply :=
-- {id_map := @id_map P, comp_map := @comp_map P}

inductive W : I ‚Üí Type u
-- | mk {i : I} (a : P.A i) (f : ‚àÄ j : I, P.B i a j ‚Üí W j) : W i
| mk {i : I} (a : P.A i) (f : P.B i a ‚ü∂ W) : W i

-- inductive W' : I -> Type u
-- | mk {a : A} : (‚àÄ k : K a, W' (f a k)) ‚Üí W' (g a)

def W_dest (P : pfunctor I I) {i} : W P i ‚Üí P.obj (W P) i
| ‚ü®a, f‚ü© := ‚ü®a, f‚ü©

def W_mk {i} : P.obj (W P) i ‚Üí W P i
| ‚ü®a, f‚ü© := ‚ü®a, f‚ü©

@[simp] theorem W_dest_W_mk {i} (p : P.obj (W P) i) : P.W_dest (P.W_mk p) = p :=
by cases p; reflexivity

@[simp] theorem W_mk_W_dest {i} (p : W P i) : P.W_mk (P.W_dest p) = p :=
by cases p; reflexivity

variables {P}

-- @[simp]
-- lemma fst_map {Œ± Œ≤ : fam I} (x : P.apply.obj Œ± _) (f : Œ± ‚ü∂ Œ≤) :
--   (f <$> x).1 = x.1 := by { cases x; refl }

-- @[simp]
-- lemma iget_map [decidable_eq P.A] {Œ± Œ≤ : Type u} [inhabited Œ±] [inhabited Œ≤]
--   (x : P.apply Œ±) (f : Œ± ‚Üí Œ≤) (i : P.Idx)
--   (h : i.1 = x.1) :
--   (f <$> x).iget i = f (x.iget i) :=
-- by { simp [apply.iget],
--      rw [dif_pos h,dif_pos];
--      cases x, refl, rw h, refl }

end pfunctor

/-
Composition of polynomial functors.
-/

namespace pfunctor

/-
def comp : pfunctor.{u} ‚Üí pfunctor.{u} ‚Üí pfunctor.{u}
| ‚ü®A‚ÇÇ, B‚ÇÇ‚ü© ‚ü®A‚ÇÅ, B‚ÇÅ‚ü© := ‚ü®Œ£ a‚ÇÇ : A‚ÇÇ, B‚ÇÇ a‚ÇÇ ‚Üí A‚ÇÅ, Œª ‚ü®a‚ÇÇ, a‚ÇÅ‚ü©, Œ£ u : B‚ÇÇ a‚ÇÇ, B‚ÇÅ (a‚ÇÅ u)‚ü©
-/

variables {I J K : Type u} (P‚ÇÇ : pfunctor.{u} J K) (P‚ÇÅ : pfunctor.{u} I J)

def comp : pfunctor.{u} I K :=
‚ü® Œª i, Œ£ a‚ÇÇ : P‚ÇÇ.1 i, P‚ÇÇ.2 _ a‚ÇÇ ‚ü∂ P‚ÇÅ.1,
-- ‚ü® Œ£ a‚ÇÇ : P‚ÇÇ.1 _, P‚ÇÇ.2 _ a‚ÇÇ ‚Üí P‚ÇÅ.1, ¬≤
  Œª k a‚ÇÇa‚ÇÅ i, Œ£ j (u : P‚ÇÇ.2 _ a‚ÇÇa‚ÇÅ.1 j), P‚ÇÅ.2 _ (a‚ÇÇa‚ÇÅ.2 u) i ‚ü©

def comp.mk {Œ± : fam I} {k} (x : P‚ÇÇ.obj (P‚ÇÅ.obj Œ±) k) : (comp P‚ÇÇ P‚ÇÅ).obj Œ± k :=
‚ü® ‚ü®x.1,x.2 ‚â´ Œª j, sigma.fst‚ü©, Œª i a‚ÇÇa‚ÇÅ, (x.2 _).2 a‚ÇÇa‚ÇÅ.2.2 ‚ü©

def comp.get {Œ± : fam I} {k} (x : (comp P‚ÇÇ P‚ÇÅ).obj Œ± k) : P‚ÇÇ.obj (P‚ÇÅ.obj Œ±) k :=
‚ü® x.1.1, Œª j a‚ÇÇ, ‚ü®x.1.2 a‚ÇÇ, Œª i a‚ÇÅ, x.2 ‚ü®j, a‚ÇÇ, a‚ÇÅ‚ü©‚ü© ‚ü©

end pfunctor

/-
Lifting predicates and relations.
-/

namespace pfunctor
variables {I J : Type u} {P : pfunctor.{u} I J}
open functor

noncomputable def classical.indefinite_description' {Œ± : Sort*} (p : Œ± ‚Üí Prop) (h : ‚àÉ (x : Œ±), p x) : psigma p :=
let ‚ü®x,h'‚ü© := classical.indefinite_description p h in ‚ü®x,h'‚ü©

namespace tactic

open tactic .

meta def mk_constructive_aux : expr ‚Üí expr ‚Üí tactic expr
| e `(‚àÉ x : %%t, %%b) :=
  do e ‚Üê mk_mapp ``classical.indefinite_description' [none,none,e],
     t ‚Üê infer_type e,
     mk_constructive_aux e t <|> pure e
| e `(@psigma %%Œ± %%f) :=
  do id_f ‚Üê mk_mapp ``id [Œ±],
     v ‚Üê mk_local_def `v Œ±,
     f' ‚Üê head_beta $ f v,
     v' ‚Üê mk_local_def `v' f',
     fn ‚Üê mk_constructive_aux v' f',
     t ‚Üê infer_type fn >>= lambdas [v],
     fn ‚Üê lambdas [v,v'] fn,
     r ‚Üê mk_mapp ``psigma.map [Œ±,Œ±,f,t,id_f],
     pure $ r fn e
| e _ := failed

setup_tactic_parser

meta def mk_constructive (n : parse ident) : tactic unit :=
do h ‚Üê get_local n,
   (vs,t) ‚Üê infer_type h >>= mk_local_pis,
   e' ‚Üê mk_constructive_aux (h.mk_app vs) t,
   -- let e' := e.mk_app vs,
   e' ‚Üê lambdas vs e',
   note h.local_pp_name none e',
   clear h

meta def apply_symm (n : name) : tactic expr :=
do e ‚Üê mk_const n,
   (vs,t) ‚Üê infer_type e >>= mk_local_pis,
   e' ‚Üê mk_eq_symm $ e.mk_app vs,
   lambdas vs e'

meta def fold (ns : parse ident*) (ls : parse location) : tactic unit :=
do hs ‚Üê ns.mmap $ get_eqn_lemmas_for tt,
   hs ‚Üê hs.join.mmap apply_symm,
   (s,u) ‚Üê mk_simp_set tt [] (hs.map $ simp_arg_type.expr ‚àò to_pexpr),
   ls.try_apply (Œª h, () <$ simp_hyp s u h) (simp_target s u)
   -- simp_target s u

run_cmd add_interactive [``fold,``mk_constructive]

end tactic

@[simp]
lemma then_def {X Y Z : fam I} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) {i} (x : X i) : (f ‚â´ g) x = g (f x) := rfl

theorem liftp_iff {Œ± : fam I} {X : fam J} (p : Œ† i, Œ± i ‚Üí Prop) (x : X ‚ü∂ P.obj Œ±) :
  liftp p x ‚Üî ‚àÄ j (y : X j), ‚àÉ a f, x y = ‚ü®a, f‚ü© ‚àß ‚àÄ i a, p i (f a) :=
begin
  split,
  { rintros ‚ü®y, hy‚ü© j z, cases h : y z with a f,
    refine ‚ü®a, Œª i a, subtype.val (f a), _, Œª i a, subtype.property (f a)‚ü©, --, Œª i, (f i).property‚ü©,
    fold pfunctor.map pfunctor.obj at *,
    simp [hy.symm, (‚â´), h, map_eq],
    simp [(‚àò),fam.subtype.val], },
  introv hv, dsimp [liftp],
  mk_constructive hv,
  -- replace hv := Œª j k, (classical.indefinite_description' _ (hv j k)),
  -- replace hv : Œ† (j : J) (k : X j),
  --   Œ£' (a : P.A j) (f : P.B j a ‚ü∂ Œ±), x j k = ‚ü®a, f‚ü© ‚àß ‚àÄ (i : I) (a : P.B j a i), p i (f i a) :=
  --   Œª j k, psigma.map id (Œª i h, classical.indefinite_description' _ h) (hv j k),
  let F‚ÇÄ := Œª j k, (hv j k).1,
  let F‚ÇÅ : Œ† j k, P.B j (F‚ÇÄ j k) ‚ü∂ Œ± := Œª j k, (hv j k).2.1,
  have F‚ÇÇ : ‚àÄ j k, x k = ‚ü®F‚ÇÄ j k,F‚ÇÅ j k‚ü© := Œª j k, (hv j k).2.2.1,
  have F‚ÇÉ : ‚àÄ j k i a, p i (F‚ÇÅ j k a) := Œª j k, (hv j k).2.2.2,
  refine ‚ü®Œª j x, ‚ü®F‚ÇÄ j x,Œª i y, ‚ü®F‚ÇÅ j x y,F‚ÇÉ j x i y‚ü©‚ü©,_‚ü©,
  ext : 2, dsimp, rw F‚ÇÇ, refl
end

theorem liftr_iff {Œ± : fam I} (r : Œ† i, Œ± i ‚Üí Œ± i ‚Üí Prop) {X : fam J} (x y : X ‚ü∂ P.obj Œ±) :
  liftr r x y ‚Üî ‚àÄ j (z : X j), ‚àÉ a f‚ÇÄ f‚ÇÅ, x z = ‚ü®a, f‚ÇÄ‚ü© ‚àß y z = ‚ü®a, f‚ÇÅ‚ü© ‚àß ‚àÄ i a, r i (f‚ÇÄ a) (f‚ÇÅ a) :=
begin
  split,
  { rintros ‚ü®u, xeq, yeq‚ü© j z, cases h : u z with a f,
    use [a, Œª i b, (f b).val.fst, Œª i b, (f b).val.snd],
    split, { rw [‚Üêxeq, then_def, h], refl },
    split, { rw [‚Üêyeq, then_def, h], refl },
    intros i a, exact (f a).property },
  rintros hv, dsimp [liftr],
  mk_constructive hv,
  let F‚ÇÄ := Œª j k, (hv j k).1,
  let F‚ÇÅ : Œ† j k, P.B j (F‚ÇÄ j k) ‚ü∂ Œ± := Œª j k, (hv j k).2.1,
  let F‚ÇÇ : Œ† j k, P.B j (F‚ÇÄ j k) ‚ü∂ Œ± := Œª j k, (hv j k).2.2.1,
  fold pfunctor.map,
  have F‚ÇÉ : ‚àÄ j k, x k = ‚ü®F‚ÇÄ j k,F‚ÇÅ j k‚ü© := Œª j k, (hv j k).2.2.2.1,
  have F‚ÇÑ : ‚àÄ j k, y k = ‚ü®F‚ÇÄ j k,F‚ÇÇ j k‚ü© := Œª j k, (hv j k).2.2.2.2.1,
  have F‚ÇÖ : ‚àÄ j k i a, r i (F‚ÇÅ j k a) (F‚ÇÇ j k a) := Œª j k, (hv j k).2.2.2.2.2,
  refine ‚ü®Œª j x, ‚ü®F‚ÇÄ j x,Œª i y, _‚ü©,_‚ü©,
  { refine ‚ü®(F‚ÇÅ j x y,F‚ÇÇ j x y),F‚ÇÖ _ _ _ _‚ü© },
  split; ext : 2; [rw F‚ÇÉ,rw F‚ÇÑ]; refl,
end

end pfunctor

/-
Facts about the general quotient needed to construct final coalgebras.

TODO (Jeremy): move these somewhere.
-/

namespace quot

def factor {Œ± : Type*} (r s: Œ± ‚Üí Œ± ‚Üí Prop) (h : ‚àÄ x y, r x y ‚Üí s x y) :
  quot r ‚Üí quot s :=
quot.lift (quot.mk s) (Œª x y rxy, quot.sound (h x y rxy))

def factor_mk_eq {Œ± : Type*} (r s: Œ± ‚Üí Œ± ‚Üí Prop) (h : ‚àÄ x y, r x y ‚Üí s x y) :
  factor r s h ‚àò quot.mk _= quot.mk _ := rfl

end quot
